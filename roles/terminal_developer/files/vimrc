set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'gmarik/Vundle'

" Libs
Plugin 'tomtom/tlib_vim'
Plugin 'Shougo/vimproc'
Plugin 'tpope/timl'
Plugin 'MarcWeber/vim-addon-mw-utils'

" General
Plugin 'gorkunov/smartpairs.vim'
Plugin 'mbbill/undotree'
Plugin 'vim-scripts/YankRing.vim'
Plugin 'kien/ctrlp.vim'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-abolish'
Plugin 'tpope/vim-unimpaired'
Plugin 'tpope/vim-commentary'
Plugin 'tpope/vim-fugitive'
Plugin 'scrooloose/syntastic'
Plugin 'plasticboy/vim-markdown'
Plugin 'tacahiroy/ctrlp-funky'
Plugin 'Soares/butane.vim'
Plugin 'tmhedberg/matchit'
Plugin 'editorconfig/editorconfig-vim'
Plugin 'airblade/vim-gitgutter'
if &term =~ '256color$' || has('gui_running')
    Plugin 'Valloric/YouCompleteMe'
else
    Plugin 'altercation/vim-colors-solarized.git'
endif
Plugin 'junegunn/vim-easy-align'
Plugin 'mtth/scratch.vim'
" Plugin 'majutsushi/tagbar'

" Colours / Style
Plugin 'chriskempson/base16-vim'
Plugin 'bling/vim-airline'

" CSV
" Plugin 'chrisbra/csv.vim'

" Jade
Plugin 'digitaltoad/vim-jade'

" Haskell
" Plugin 'travitch/hasksyn'
Plugin 'dag/vim2hs'
Plugin 'eagletmt/neco-ghc'
Plugin 'godlygeek/tabular'
" Plugin 'lukerandall/haskellmode-vim'
Plugin 'eagletmt/ghcmod-vim'
Plugin 'kana/vim-textobj-user'
Plugin 'kana/vim-textobj-indent'

" Javascript
Plugin 'jelera/vim-javascript-syntax'
" Plugin 'pangloss/vim-javascript'
Plugin 'marijnh/tern_for_vim'

" Tmux
Plugin 'jgdavey/tslime.vim'
Plugin 'christoomey/vim-tmux-navigator'
" Plugin 'mhinz/vim-tmuxify'
" Plugin 'benmills/vimux'

" Yaml
Plugin 'stephpy/vim-yaml'

" Clojure
" Plugin 'tpope/vim-fireplace'
" Plugin 'guns/vim-clojure-highlight'
" Plugin 'guns/vim-clojure-static'
" " Plugin 'tpope/vim-fireplace'
" " Plugin 'typedclojure/vim-typedclojure'
" Plugin 'guns/vim-sexp'
" " Plugin 'tpope/vim-sexp-mappings-for-regular-people'
" " Plugin 'web-indent'
" Plugin 'luochen1990/rainbow'

call vundle#end()
filetype plugin indent on


if &term =~ '^screen'
    " tmux will send xterm-style keys when its xterm-keys option is on
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"
endif

" VIM Customizations
set nocompatible
set modelines=0
set encoding=utf-8
set scrolloff=5
set sidescrolloff=5
set display+=lastline
set autoindent
set complete-=i
set completeopt-=preview
set shiftround
set nrformats-=octal
set smarttab
set showcmd
set hidden
set wildmenu
set wildmode=list:longest
set wildignore=*.o,*.obj,*.bak,*.exe
set visualbell
set ttyfast
set ruler
set backspace=indent,eol,start
set relativenumber
set lazyredraw
set number
set hls
set timeoutlen=10000
set nofoldenable
filetype plugin on

if &encoding ==# 'latin1' && has('gui_running')
	set encoding=utf-8
endif

" set ignorecase
set smartcase
" set gdefault
set incsearch
set showmatch
set hlsearch
set linebreak
set breakat=\ 

set backupdir=/tmp,~/tmp,/storage/emulated/legacy/tmp " backups (~)
set directory=/tmp,~/tmp,/storage/emulated/legacy/tmp " swap files
" set backup               " enable backups

" Code Style
set tabstop=4
set shiftwidth=4
set softtabstop=4

" Vimdiff
set diffopt+=iwhite

" Pathogen
" call pathogen#infect()
" call pathogen#helptags()

" Visual Style
" let z=$COLORTERM
" if &term =~ '256color$' || has('gui_running') || &term == 'nvim' || $COLORTERM =~ "."
    set t_Co=256
    set laststatus=2
    set noshowmode
    let base16colorspace=256
    set background=dark
    colorscheme base16-default
    if &listchars ==# 'eol:$'
        if !has('win32') && (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8')
            set list
            let &listchars = "tab:\u21e5 ,trail:\u2423,extends:\u21c9,precedes:\u21c7,nbsp:\u00b7"
        endif
    endif
    set cursorline
    augroup CursorLine
        autocmd!
        au insertenter * set nocursorline
        au insertleave * set cursorline
    augroup end

" else
"     set background=dark
"     colorscheme solarized
" endif

" = vim-rooter  ===================================================
let g:rooter_manual_only = 1

" = Sexp ==========================================================
let g:sexp_filetypes = ''

" = EasyClip ======================================================
let g:EasyClipUseCutDefaults = 0
" nmap <leader>d <Plug>MoveMotionPlug
" xmap <leader>d <Plug>MoveMotionXPlug
" nmap <leader>D <Plug>MoveMotionEndOfLinePlug
" nmap <leader>dd <Plug>MoveMotionLinePlug
" nmap <leader>c :EasyClipBeforeYank<cr>c
" nmap <leader>C :EasyClipBeforeYank<cr>C

" = Breakindent Patch =============================================
if exists("&breakindent")
    set showbreak=..
    set breakindentopt=shift:0,sbr
    set breakindent
endif

" = GitGutter  ====================================================
let g:gitgutter_sign_column_always=1
let g:gitgutter_realtime=1
set updatetime=750

" = Airline =======================================================

if ! has('gui_running')
    set ttimeoutlen=10
    augroup fastescape
        autocmd!
        au insertenter * set timeoutlen=0
        au insertleave * set timeoutlen=1000
    augroup end
endif

let g:airline#extensions#whitespace#enabled = 0
let g:airline_powerline_fonts = 1
" let g:airline#extensions#tabline#enabled = 1

" python from powerline.vim import setup as powerline_setup
" python powerline_setup()
" python del powerline_setup

" = Number Switching ================================================

augroup LineNumberFlip
	autocmd!
	au insertenter * :set norelativenumber
	au insertleave * :set relativenumber
augroup end
map <leader>/ :set norelativenumber<CR>

" = Fugitive ======================================================

autocmd BufReadPost fugitive://* set bufhidden=delete
set diffopt+=vertical

" = YouCompleteMe ===================================================

let g:ycm_key_list_select_completion = ['<Down>']
let g:ycm_semantic_triggers = {'haskell' : ['.']}


"
" = GUI Visual Style ================================================

set guifont=Source\ Code\ Pro\ for\ Powerline\ Medium\ 12
set guioptions-=T
set guioptions-=r
set guioptions-=t
syntax on
let g:Powerline_symbols = 'fancy'
autocmd BufEnter * :syntax sync fromstart

" = Tern ==============================================================

let g:tern_show_argument_hints='on_hold'
" let g:tern_map_keys=1

" = Haskell ===========================================================

let g:haddock_browser = "/usr/bin/chromium-browser --new-window "
let g:haddock_docdir = "/usr/share/doc/ghc-doc/html/"

" let g:ghc = "/opt/ghc/7.8.4/bin/ghc"

let g:haskell_conceal_wide = 0
let g:haskell_conceal              = 0
let g:haskell_conceal_enumerations = 0
let g:hasksyn_indent_search_backward = 100
let g:hasksyn_dedent_after_return = 1
let g:hasksyn_dedent_after_catchall_case = 1

let g:haskell_conceal_wide  = 0
let g:haskell_quasi         = 0
let g:haskell_interpolation = 0
let g:haskell_regex         = 0
let g:haskell_jmacro        = 0
let g:haskell_shqq          = 0
let g:haskell_sql           = 0
let g:haskell_json          = 0
let g:haskell_xml           = 0

" au BufEnter *.hs compiler ghc

" = Neco-ghc  =======================================================
let g:necoghc_enable_detailed_browse = 1

" = Key Bindings ======================================================
" let mapleader = "\<space>"
map U <C-r>
nnoremap * :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
nmap <silent> <leader>/ :nohlsearch<ESC>
imap <Home> <esc>^i
nnoremap <F5> :UndotreeToggle<CR>
nnoremap Y y$
vnoremap <silent> s //e<C-r>=&selection=='exclusive'?'+1':''<CR><CR>
    \:<C-u>call histdel('search',-1)<Bar>let @/=histget('search',-1)<CR>gv
omap s :normal vs<CR>

" Plugin: vim-multiple-cursors
let g:multi_cursor_use_default_mapping=0
let g:multi_cursor_next_key='<C-A-n>'
let g:multi_cursor_prev_key='<C-n>'
let g:multi_cursor_skip_key='<C-A-m>'
let g:multi_cursor_quit_key='<Esc>'

" = Syntastic ======================================================
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
let g:syntastic_style_error_symbol = '✗'
let g:syntastic_style_warning_symbol = '⚠'
let g:syntastic_auto_loc_list=1
let g:syntastic_aggregate_errors = 1
let g:syntastic_javascript_checkers = ["eslint"]

" Plugin: CtrlP
let g:ctrlp_map = '<C-f>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_regexp = 1
let g:ctrlp_max_height = 22
let g:ctrlp_extensions = ['funky']
let g:ctrlp_funky_syntax_highlight = 1
" let g:ctrlp_funky_matchtype = 'path'
let g:ctrlp_custom_ignore = 'node_modules\|DS_Store\|\.git|bin|dist'
map <C-B> :CtrlPBuffer<CR>

" Plugin: plasticboy/vim-markdown
let g:vim_markdown_folding_disabled=1
autocmd FileType md set wrap|set linebreak|set nolist "|set textwidth=0|set wrapmargin=0|set formatoptions+=1


function SetClojureOptions()
" Plugin: Rainbow
    let g:rainbow_active = 1
    let g:rainbow_conf = {
    \   'guifgs': ['brown', 'Darkblue', 'darkgreen', 'darkcyan', 'darkred', 'darkmagenta', 'brown', 'darkmagenta', 'Darkblue', 'darkgreen', 'darkcyan', 'darkred', 'red'],
    \   'ctermfgs': ['brown', 'Darkblue', 'darkgreen', 'darkcyan', 'darkred', 'darkmagenta', 'brown', 'darkmagenta', 'Darkblue', 'darkgreen', 'darkcyan', 'darkred', 'red'],
    \   'operators': '_,_',
    \   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold']
    \}
    " nmap <Enter> :Eval<cr>
    " RainbowParenthesisToggle
    " au VimEnter * RainbowParenthesesToggle
    " au Syntax * RainbowParenthesesLoadRound
    " au Syntax * RainbowParenthesesLoadSquare
    " au Syntax * RainbowParenthesesLoadBraces
endfunction
autocmd Filetype clojure call SetClojureOptions()

" Vimux ===========================================================
let g:VimuxOrientation = "h"
let g:tslime_ensure_trailing_newlines = 1

" function! TestFile_Set()
" 	let g:testfile__file_to_test = @%
" 	let g:testfile__filetype_to_test = &ft
" 	echo "Test file set to " . @%
" endfunction
" 
" function! TestFile_Run()
" 	if exists("g:testfile__file_to_test")
" 		echo "js test file: " . g:testfile__file_to_test
" 		call SendToTmux("./node_modules/.bin/test-this-file '" . g:testfile__file_to_test . "'\n")
" 	endif
" endfunction

function RunUnitTest()
    if (exists("g:unittest"))
        " if &term == 'nvim'
        "     exec "terminal " . g:unittest
        " else
            call Send_keys_to_Tmux("enter")
            call SendToTmux(g:unittest . "\n")
        " endif
    endif
endfunction
function SetUnitTest()
    if (exists("g:unittest"))
        let g:unittest = input("specify command: ", g:unittest)
    else
        let g:unittest = input("specify command: ", "")
    endif
endfunction


nmap <leader>R <Plug>SetTmuxVars
nmap <leader><leader>R <Plug>SetTmuxVars
vmap <leader><Enter> :call SendToTmux(@*)<CR>
nmap <leader><Enter> <S-v><leader><Enter>
vmap <leader>r :call SendToTmux(@*)<CR><ESC>
nmap <leader><leader>r :call SetUnitTest()<CR>
nmap <leader>r :call RunUnitTest()<CR>
nmap <leader>c :call Send_keys_to_Tmux("C-c")<CR>

" vmap <C-Space>r :call SendToTmux(@* . "\n")<CR>
autocmd BufWritePost * :call RunUnitTest()
au BufNewFile,BufRead *.raml set filetype=yaml

:com ToggleMenu if &go=~'m'|set go-=m|else|set go+=m|endif
set go-=m

nnoremap <silent> n   n:call HLNext(0.1)<cr>
nnoremap <silent> N   N:call HLNext(0.1)<cr>
nnoremap <silent> <leader>s V:'<,'>ScratchSelection<CR>:sleep 250m<CR><C-w>j

function! HLNext (blinktime)
	let [bufnum, lnum, col, off] = getpos('.')
	let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
	let target_pat = '\c\%#'.@/
	let ring = matchadd('ErrorMsg', target_pat, 101)
	redraw
	exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
	call matchdelete(ring)
	redraw
endfunction

function! Gpullrequest()
    let cmd = 'git diff --name-only $(git branch | grep ''^\*'' | sed ''s/^* //'') $(git merge-base $(git branch | grep ''^\*'' | sed ''s/^* //'') master) | sed ''s/$/:1:Changed File/g'' |  sed "s/^/$(git rev-parse --show-cdup |sed ''s/\//\\\//g'')/g" > ' . "/tmp/$USER.vim.cfile"
    let z = system(cmd)
    execute "cfile /tmp/" . $USER . ".vim.cfile"
endfunction

if &term == 'nvim'
    " if @% =~ '^term:'
    tnoremap <c-h> <c-\><c-n><c-w><c-h>
    tnoremap <c-j> <c-\><c-n><c-w><c-j>
    tnoremap <c-k> <c-\><c-n><c-w><c-k>
    tnoremap <c-l> <c-\><c-n><c-w><c-l>
endif

imap <C-j> <ESC><C-j>
imap <C-h> <ESC><C-h>
imap <C-k> <ESC><C-k>
imap <C-l> <ESC><C-l>

" Allow lowercase commands
function! CommandCabbr(abbreviation, expansion)
  execute 'cabbr ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction
command! -nargs=+ CommandCabbr call CommandCabbr(<f-args>)

" Map `:bc` ex command to Bclose (to close buffers with multiple windows
CommandCabbr bc Bclose

